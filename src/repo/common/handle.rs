/*
 * Copyright 2019-2021 Wren Powell
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

use std::io::{self, Read};

use serde::{Deserialize, Serialize};
use uuid::Uuid;

use super::id_table::UniqueId;

/// A checksum used for uniquely identifying a chunk.
pub type ChunkHash = [u8; blake3::OUT_LEN];

/// Compute the BLAKE3 checksum of the given `data` and return the result.
pub fn chunk_hash(data: &[u8]) -> ChunkHash {
    blake3::hash(data).into()
}

/// A chunk of data generated by the chunking algorithm.
#[derive(Debug, PartialEq, Eq, Hash, Clone, Copy, Default, Serialize, Deserialize)]
pub struct Chunk {
    /// The size of the chunk in bytes.
    pub size: u32,

    /// The checksum of the chunk.
    pub hash: ChunkHash,
}

/// A handle for accessing data in a repository.
///
/// An `ObjectHandle` is like an address for locating data stored in a `KeyRepo`.
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ObjectHandle {
    /// The ID of this handle which is unique within its repository.
    ///
    /// Handle IDs are only guaranteed to be unique within the same repository.
    pub id: UniqueId,

    /// The checksums of the chunks which make up the data.
    pub chunks: Vec<Chunk>,
}

impl ObjectHandle {
    /// The size of the object in bytes.
    pub fn size(&self) -> u64 {
        self.chunks.iter().map(|chunk| chunk.size as u64).sum()
    }
}

/// A value that uniquely identifies the contents of an object at a certain point in time.
///
/// A `ContentId` is like a checksum of the data in an object except it is cheap to compute.
/// A `ContentId` can be compared with other `ContentId` values to determine if the contents of two
/// objects are equal. However, these comparisons are only valid within the same repository;
/// content IDs from different repositories are never equal. To compare data between repositories,
/// you should use [`compare_contents`].
///
/// `ContentId` is opaque, but it can be serialized and deserialized. The value of a `ContentId` is
/// stable, meaning that they can be compared across invocations of the library.
///
/// [`compare_contents`]: crate::repo::ContentId::compare_contents
#[derive(Debug, PartialEq, Eq, Hash, Clone, Serialize, Deserialize)]
pub struct ContentId {
    // We can't compare content IDs from different repositories because those repositories may have
    // different a chunking configuration. To ensure consistent behavior, we include the
    // repository's UUID to ensure that content IDs from different repositories are never equal.
    /// The ID of the repository the object is associated with.
    pub(super) repo_id: Uuid,

    /// The checksums of the chunks which make up the data.
    pub(super) chunks: Vec<Chunk>,
}

impl ContentId {
    /// The size of the contents represented by this content ID in bytes.
    pub fn size(&self) -> u64 {
        self.chunks.iter().map(|chunk| chunk.size as u64).sum()
    }

    /// Return whether this content ID has the same contents as `other`.
    ///
    /// This compares the contents of this content ID with `other` without reading any data from the
    /// data store. This is much faster than calculating a checksum of the object, especially if
    /// reading from the data store would be prohibitively slow.
    ///
    /// This method compares this content ID with `other` in chunks, and will fail early if any
    /// chunk does not match. This means that it may not be necessary to read `other` in its
    /// entirety to determine that the contents are different.
    ///
    /// Because `other` only implements `Read`, this cannot compare the contents by size. If you
    /// need to compare this content ID with a file or some other source of data with a known size,
    /// you should use [`size`] to query the size of this content ID so you can handle the trivial
    /// case of the contents having different sizes.
    ///
    /// If you need to compare the contents of two objects from the same repository, it's cheaper to
    /// check if their `ContentId` values are equal instead.
    ///
    /// # Errors
    /// - `Error::Io`: An I/O error occurred.
    ///
    /// [`size`]: crate::repo::ContentId::size
    pub fn compare_contents(&self, mut other: impl Read) -> crate::Result<bool> {
        let mut buffer = Vec::new();

        for chunk in &self.chunks {
            // Grow the buffer so it's large enough.
            if buffer.len() < chunk.size as usize {
                buffer.resize(chunk.size as usize, 0u8);
            }

            if let Err(error) = other.read_exact(&mut buffer[..chunk.size as usize]) {
                return if error.kind() == io::ErrorKind::UnexpectedEof {
                    Ok(false)
                } else {
                    Err(error.into())
                };
            }

            if chunk.hash != chunk_hash(&buffer[..chunk.size as usize]) {
                return Ok(false);
            }
        }

        // Handle the case where `other` is longer than this object.
        if other.read(&mut buffer)? != 0 {
            return Ok(false);
        }

        Ok(true)
    }
}
